= Introduction =

Classes are the core of EMP Ria. The main goals of EMP Ria classes are easy declaration and powerful type hinting. Type hinting is completely optional, but is very welcome, as it empowers classes a lot. 

= Declaration =

{{{
CLASS(
  'MyClass', EXTENDS(MyBaseClass), [
  ]);
}}}

Class may be extended from other classes. All classes extend base class called Class implicitly.

{{{
CLASS(
  'MyClass', IMPLEMENTS(MyIfc), [
  ]);
}}}

Class may implement [Interfaces]. This ensures that all methods declared in interface are implemented in class. Also instance of a class is implicit instance on interface, so it can pass type hint. Rules of method implementation are similar to method override rules.

{{{
CLASS(
  'MyClass', [
    // contains public properties (ONLY public)
    String, 'value', 

    [[String]],
    function setValue(value) {
      this.value = value;
    }
  ]);
}}}

Class may contain properties. Property is complex of protected field and public getter and setter. Property name can be only valid JS variable name and can NOT start with *_$_* or end with *`_`*. Getter name is constructed by capitalizing field name and prefixing with *_is_* in case of Boolean properties or *_get_* otherwise. Setter name is constructed by capitalizing field name and prefixig with *_set_*. If class contains no explicit declaration of getter or setter or both, defaults are added implicitly.

Properties can be marked with FINAL, ABSTRACT and READONLY. Final property means that getter and setter can NOT be overridden in descendants. Abstract property means that getter and setter MUST be overridden in descendants. Property may be either FINAL or ABSTRACT. READONLY property has no setter. Declaring explicit setter for readonly property MUST trigger exception. Explicit getters and setter MUST be marked with same flags as property.

{{{
CLASS(
  'MyClass', EXTENDS(MyBaseClass), IMPLEMENTS(MyIfc), [
    // contains public ctor
    [[String]],
    function $(value) {
      BASE();
    }
  ]);
}}}

Class may have explicit constructor (method named *$*). Constructors are always public. Constructors do not return result and their return type is omitted and defaults to *VOID*. If constructor returns anything exception is raised. Constructor body should have call to constructor of base class. If constructor has no explicit call to base constructor and base class has parameterless constructor or all parameters are optional then base constructor is called implicitly before first statement of constructor. If constructor has no explicit call to base constructor and implicit call of base class constructor is impossible exception is raised. It's a good practice to put explicit base constructor call as a first statement of constructor declaration. If constructor has parameters with same name (excluding suffix *_`_`_*) as it's own property value of parameter is set to property via setter.

Protected fields are not type hinted and can contain anything. Fields are introduced only in constructor. If unknown field is assigned in method exception is raised. Fields of properties are introduced implicitly.

{{{
CLASS(
  'MyClass', [
    VOID, function publicMember() {
    },

    ABSTRACT, VOID, function protectedMember_() {
    }
  ]);
}}}

Class may contain public and protected method. Methods are considered protected if method name ends with _`_`_ and public otherwise. Method name can NOT start with *$*. Methods have return and it can be type hinted or *VOID* or anything (if type hint is omitted). Also method may have arguments. Argument is considered optional if it's name ends with *_`_`_*. Variable arguments are NOT supported. It's recommended to pass variable arguments as last optional array argument (it also can be type hinted).

All methods of class are considered virtual. This means that any descendant class can override any method. To prevent override methods can be marked with *FINAL*. To make system more error prune, it is required to mark any explicit method's override with *OVERRIDE*. If *OVERRIDE* is omitted warning will be raised and call to BASE is prohibited. Methods can be marked with *ABSTRACT* if its override in descendant classes is required. Abstract methods can still have body and are callable like normal methods and from overrides via BASE(). Abstract methods do not make class abstract.

When method overrides base method, it may introduce additional optional parameters in the end of parameters list. Also it may wide type hint of base method. For example, if type hint was String, descendant implementation may change it to Any, in case of classes override may change type hint to base class of class declared in type hint of base implementation.

{{{
CLASS(
  ABSTRACT, 'MyClass', [
  ]);
}}}

Classes can be marked as *ABSTRACT* if it's direct instantiation is forbidden or *FINAL* if it's NOT extendable. Class can not be marked as *ABSTRACT* and *FINAL* at the same time.

{{{
CLASS(
  // Classes can be annotated
  [MyAnnotation],
  'MyClass', [    
  ]);
}}}

Class, its constructor, properties and public methods can be annotated.  All [Annotations] and their parameters can be reflected, as well as properties, constructor and public members.

= UnSafe classes =

Class declaration may be marked with *UNSAFE*. This option makes class more like structure, means no scope binding, hidden fields and protected methods (protected methods are public, but can not be reflected). Instantiation of such class is much cheaper in terms of CPU. 

{{{
CLASS(UNSAFE
  'MyUnSafeClass', [
  ]);
}}}

Unsafe flag is not inherited. But If you extends from unsafe class you may make child also unsafe.

= Usage =

{{{
CLASS(
  [empx.domx.BaseAnnotation(true, 5)],
  'BaseComparatorImpl',
      EXTENDS(empx.domx.BaseClass), 
      IMPLEMENTS(empx.domx.StringNumberComparatorIfc), [

    [empx.domx.BaseAnnotation(false)],
    String, 'myProp',

    function $() {
      BASE(5);
    },

    [[String, Number]],
    Boolean, function compare(x, y) { 
      return x === String(y) 
    },

    VOID, function protectedMember_() {
      BASE(this.myProp + 5);
    }
  ]);

var instance = BaseComparatorImpl();
instance.compare('1', 1); // true

instance.setMyProp(2);
instance.getMyProp(); // 2
}}}

= Low Level API =

{{{
empx.domx.BaseComparatorImpl = function () {
  function BaseComparatorImpl() { var factory = Dictionary.$$ || ria.__API.init;
    return factory(this, BaseComparatorImpl, BaseComparatorImpl.prototype.$, arguments); };
  ria.__API.clazz(BaseComparatorImpl, 'empx.domx.BaseComparatorImpl', empx.domx.BaseClass
    , [empx.domx.StringNumberComparatorIfc], [empx.domx.BaseAnnotation(true, 5)]);

  BaseComparatorImpl.prototype.getMyProp = function () { return this.myProp; };
  BaseComparatorImpl.prototype.setMyProp = function (value) { this.myProp = value; };
  ria.__API.property(BaseComparatorImpl, 'myProp', String, [empx.domx.SomeAnnotation]
      , BaseComparatorImpl.prototype.getMyProp
      , BaseComparatorImpl.prototype.setMyProp);

  BaseComparatorImpl.prototype.$ = function () {
    empx.domx.BaseClass.prototype.$.call(this, 5);
  };
  ria.__API.ctor(BaseComparatorImpl, BaseComparatorImpl.prototype.$, [], []);

  BaseComparatorImpl.prototype.compare = function (x, y) { return x === String(y) };
  ria.__API.method(BaseComparatorImpl, BaseComparatorImpl.prototype.compare
      , 'compare', Booleam, [String, Number], ['x', 'y']);

  BaseComparatorImpl.prototype.protectedMember_ = function () {
    empx.domx.BaseClass.prototype.protectedMember_.call(this, this.myProp + 5);
  };
  //#ifdef DEBUG
    ria.__API.method(BaseComparatorImpl, BaseComparatorImpl.prototype.protectedMember_
        , 'protectedMember_', ria.__API.Void, [], []);
  //#endif


  ria.__API.compile(MyClass);
  return MyClass;
}();
}}}