#summary One-sentence summary of this page.

= Introduction =

Classes are the core of EMP Ria. The main goals of EMP Ria classes are easy declaration and powerfull type hinting. Type hints are completely optional, but is very welcome, as in empowers classes a lot. 

= Declaration =

{{{
CLASS(
  'MyClass', EXTENDS(MyBaseClass), [
  ]);
}}}

Class may be extended from other classes. All classes extend base class called Class implicitly.

{{{
CLASS(
  'MyClass', IMPLEMENTS(MyIfc), [
  ]);
}}}

Class may implement [Interfaces]. This ensures that all methods declared in interface are implemented in class. Also instance of a class is implicit instance on interface, so it can pass type hint.

{{{
CLASS(
  'MyClass', [
    // contains public properties (ONLY public)
    String, 'value', 

    [String]
    function setValue(value) {
      this.value = value;
    }
  ]);
}}}

Class may contain properties. Property is complex of protected field and public getter and setter. Property name can be only valid JS variable name and can NOT start with *_$_* or end with *`_`*. Getter name is constructed by capitalizing field name and prefix *_is_* in case of Boolean properties or *_get_* otherwise. Setter name is constructed by capitalizing field name and prefix *_set_*. If class contains no explicit declaration of getter or setter or both, defaults are added implicitly.

{{{
CLASS(
  'MyClass', EXTENDS(MyBaseClass), IMPLEMENTS(MyIfc), [
    // contains public ctor
    [String]
    function $(value) {
      BASE();
    }
  ]);
}}}

Class may have explicit constructor (method named *$*). Constructors are always public. Constructors do not return result and their return type is omitted and defaults to *VOID*. If constructor returns anything exception is raised. Constructor body should have call to constructor of base class. If constructor has no explicit call to base constructor and base class has parameterless constructor or all parameters are optional then base constructor is called implicitly before first statement of constructor. If constructor has no explicit call to base constructor and implicit call of base class constructor is impossible exception is raised. It's a good practice to put explicit base constructor call as a first statement of constructor declaration. If constructor has parameters with same name (excluding suffix *_`_`_*) as it's own property value of parameter is set to property via setter.

Protected fields are not type hinted and can contain anything. Fields are introduced only in constructor. If unknown field is assigned in method exception is raised. Fields of properties are introduces implicitly.

{{{
CLASS(
  'MyClass', [
    VOID, function publicMember() {
    },

    ABSTRACT, VOID, function protectedMember_() {
    }
  ]);
}}}

Class may contain public and protected method. Methods are considered protected if method name ends with _`_`_ and public otherwise. Method name can NOT start with *$*. Methods have return and it can be type hinted or *VOID* or anything (if type hint is omitted). Also method may have arguments. Argument is considered optional if it's name ends with *_`_`_*. Variable arguments are NOT supported. It's recommended to pass variable arguments as last optional array argument (it also can be type hinted).

All methods of class are considered virtual. This means that any descendant class can override any method. To prevent override methods can be marked with *FINAL*. To make system more error prune, it is required to mark any explicit method's override with *OVERRIDE*. If *OVERRIDE* is omitted warning will be raised and call to BASE is prohibited. Methods can be marked with *ABSTRACT* if its override in descendant classes is required. Abstract methods can still have body and are callable from overrides via BASE(). Abstract methods do not make class abstract.

{{{
CLASS(
  ABSTRACT, 'MyClass', [
  ]);
}}}

Classes can be marked as *ABSTRACT* if it's direct instantiation is forbidden or *FINAL* if it's NOT extendable. Class can not be marked as *ABSTRACT* and *FINAL* at the same time.

{{{
CLASS(
  // Classes can be annotated
  [MyAnnotation]
  'MyClass', [    
  ]);
}}}

Class, its constructor, properties and public methods can be annotated.  All [Annotations] and their parameters can be reflected, as well as properties, constructor and public members.

= Usage =

{{{
CLASS(
  [empx.domx.BaseAnnotation(true, 5)],
  'BaseComparatorImpl',
      EXTENDS(empx.domx.BaseClass), 
      IMPLEMENTS(empx.domx.StringNumberComparatorIfc), [

    [empx.domx.BaseAnnotation(false)],
    String, 'myProp',

    function $() {
      BASE(5);
    },

    [String, Number],
    Boolean, function compare(x, y) { 
      return x === String(y) 
    },

    VOID, function protectedMember_() {
      BASE(this.myProp + 5);
    }
  ]);

var instance = BaseComparatorImpl();
instance.compare('1', 1); // true

instance.setMyProp(2);
instance.getMyProp(); // 2
}}}

= Low Level API =

{{{
empx.domx.BaseComparatorImpl = function () {
  function BaseComparatorImpl() { return ria.__API.init(this, BaseComparatorImpl
      , BaseComparatorImpl.prototype.$, arguments); };
  ria.__API.clazz(BaseComparatorImpl, 'empx.domx.BaseComparatorImpl', empx.domx.BaseClass
    , [empx.domx.StringNumberComparatorIfc], [empx.domx.BaseAnnotation(true, 5)]);

  ria.__API.property(BaseComparatorImpl, 'myProp', String, [empx.domx.SomeAnnotation]);
  BaseComparatorImpl.prototype.getMyProp = function () { return this.myProp; };
  ria.__API.method(BaseComparatorImpl, BaseComparatorImpl.prototype.getMyProp
      , 'getMyProp', String, [], []); /* default getter */
  BaseComparatorImpl.prototype.setMyProp = function (value) { this.myProp = value; };
  ria.__API.method(BaseComparatorImpl, BaseComparatorImpl.prototype.setMyProp
      , 'setMyProp', __API.Void, [String], ['value']); /* default setter */

  BaseComparatorImpl.prototype.$ = function () {
    empx.domx.BaseClass.prototype.$.call(this, 5);
  };
  ria.__API.ctor(BaseComparatorImpl, BaseComparatorImpl.prototype.$, [], []);

  BaseComparatorImpl.prototype.compare = function (x, y) { return x === String(y) };
  ria.__API.method(BaseComparatorImpl, BaseComparatorImpl.prototype.compare
      , 'compare', Booleam, [String, Number], ['x', 'y']);

  BaseComparatorImpl.prototype.protectedMember_ = function () {
    empx.domx.BaseClass.prototype.protectedMember_.call(this, this.myProp + 5);
  };
  //#ifdef DEBUG
    ria.__API.method(BaseComparatorImpl, BaseComparatorImpl.prototype.protectedMember_
        , 'protectedMember_', ria.__API.Void, [], []);
  //#endif


  ria.__API.compile(MyClass);
  return MyClass;
}();
}}}