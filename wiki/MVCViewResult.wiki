#summary MVC ViewResult proposal

= Introduction =

ViewResult is a base result for action methods of controllers. If controller action returns:

 # undefined - trigger an error
 # null - do nothing
 # non ViewResult - trigger an error
 # ViewResult - do view update


= Details =

{{{
CLASS(ABSTRACT, 
  'ViewResult', []);

CLASS(
  'RedirectResult', EXTENDS(ViewResult), [
    String, 'controller',
    String, 'action',
    Array, 'args'
  ]);

CLASS(ABSTRACT
  'ActivityResult', EXTENDS(ViewResult), [
    ImplementerOf(IActivity), 'activityClass'
  ]);

CLASS(
  'CloseResult', EXTENDS(ActivityResult), []);

ENUM(
  'ActionType', {
    Push: 'push',
    Shade: 'shade',
    Static: 'static',
    Update: 'update',
    BackgroundUpdate: 'bg-update'
  });

CLASS(
  'ActionResult', EXTENDS(ActivityResult), [
     Object, 'data',
     String, 'msg',
     ActionType, 'action',
     Boolean, 'orUpdate',
     SELF, 'thenAction',

     /** 
      * Chains silent update of view after parent action result completes and data is ready. 
      * If dataFuture is null this update is skipped. If dataFuture is BREAKed then 
      * all updates are canceled
      */
     [[Object, String]],
     SELF, function ChainUpdateView (data, msg_) {
       return SELF.$fromData(this.getActivityClass(), 
              ActionType.BackgroundUpdate, 
              false, data, msg_);
     }
  ]);

CLASS(
  'ActionController', EXTENDS(Controller), [
    /**
     * Redirect to new location
     */
    [[String, String, Array]],
    RedirectResult, function Redirect(controller, action, args_) {
      return RedirectResult.$fromData(controller, action, args_ || []);
    },

    /**
     * Silently updates activities of this on stack or out-of-stack with data/message, deferred
     */
    [[String, String, Array]],
    ActionResult, function PushView(activityClass, data) {
      return ActionResult.$fromData(activityClass, false, data);
    },

    /**
     * Resets stack and puts activity on top, triggers state persistence
     */
    [[ImplementerOf(IActivity), ria.async.Future]],
    ActionResult, function PushView(activityClass, data) {
       return ActionResult.$fromData(activityClass, 
              ActionType.Push, 
              false, data);
    },

    /**
     * If activity is on stack bottom, then all other activities are popped, 
     * activity is updated, state is persisted; otherwise acts like PushView
     */
    [[ImplementerOf(IActivity), ria.async.Future, String]],
    ActionResult, function PushOrUpdateView(activityClass, data, msg_) {
       return ActionResult.$fromData(activityClass, 
              ActionType.Push, 
              true, data, msg_);
    },

    /**
     * Shades top activity with this one, no state persistence. If top activity 
     * has same ActivityGroup it is popped
     */
    [[ImplementerOf(IActivity), ria.async.Future]],
    ActionResult, function ShadeView(activityClass, data) {
       return ActionResult.$fromData(activityClass, 
              ActionType.Shade, 
              false, data);
    },

    /**
     * If activity is on stack, then all activities of this class are updated, 
     * no state persistence; otherwise acts like ShadeView
     */
    [[ImplementerOf(IActivity), ria.async.Future, String]],
    ActionResult, function ShadeOrUpdateView(activityClass, data, msg_) {
       return ActionResult.$fromData(activityClass, 
              ActionType.Shade, 
              true, data, msg_);
    },

    /**
     * Puts activity in special out-of-stack flow: it's not affected by PushView or ShadeView. 
     * All activities with same ActivityGroup are stopped and removed
     */
    [[ImplementerOf(IActivity), ria.async.Future]],
    ActionResult, function StaticView(activityClass, data) {
       return ActionResult.$fromData(activityClass, 
              ActionType.Shade, 
              false, 
              data);
    },

    /**
     * If activity if found on out-of-stack, it is updated; otherwise acts like StaticView
     */
    [[ImplementerOf(IActivity), ria.async.Future, String]],
    ActionResult, function StaticOrUpdateView(activityClass, data, msg_) {
       return ActionResult.$fromData(activityClass, 
              ActionType.Shade, 
              true, data, msg_);
    },

    /**
     * Updates all activities of this class on stack and out-of-stack
     */
    [[ImplementerOf(IActivity), ria.async.Future, Array]],
    ActionResult, function UpdateView(activityClass, data, msg_) {
      return ActionResult.$fromData(activityClass, 
             ActionType.Update, 
             false, data, msg_);
    },

    /**
     * Silently updates activities of this on stack or out-of-stack with data/message, deferred
     */
    [[ImplementerOf(IActivity), Object, Array]],
    ActionResult, function BackgroundUpdateView(activityClass, data, msg_) {
      return ActionResult.$fromData(activityClass, 
             ActionType.BackgroundUpdate, 
             false, data, msg_);
    }

    /**
     * Closes all activities of this class on stack and out-of-stack. 
     * All activities that shades this one are stopped also.
     */
    [[String]],
    CloseResult, function CloseView(activityClass) {
      return CloseResult.$fromData(activityClass);
    },

    /**
     * Shows activity immediatly and pauses viewResultQueue processing
     * till modal activity is closed. Resulting future is resolved with 
     * return of getModelResult().
     */
    [[ImplementerOf(IActivity]],
    ria.async.Future, function ModalView(activityClass, rawData) {
      return this.view.modalView(activityClass, rawData);
  ]);
}}}


Examples:
{{{
CLASS(
  'SampleController', EXTENDS(ActionController), [
    function chainedUpdateSampleAction() {
      return this.PushOrUpdateView(MyActivity, dataFuture1)
                 .ChainUpdateView(dataFuture2, 'msg2')
                 .ChainUpdateView(dataFuture3, 'msg3')
    },

    function modalConfirmSampleAction() {
      var data = this.ModalView(MyConfirmBox, myConfirmBoxModel)
        .then(function (modalResult) {
          return modalResult.isOk() ? modalResult.getData() : ria.async.Future;
        })
        .thenCall(this.service.getSomeData)

      return this.PushOrUpdateView(MyActivity, data);   
    }
  ]);
}}}