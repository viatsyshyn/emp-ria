#summary Futures/Promises proposal

= Introduction =

From Wikipedia, the free encyclopedia:

    In computer science, future, promise, and delay refer to constructs used for synchronizing in some concurrent programming languages. They describe an object that acts as a proxy for a result that is initially unknown, usually because the computation of its value is yet incomplete.


= Details =

This library is based on CommonJS Promises/A proposal.

Main components are:
  
  * IFuture
  * ITask

{{{

DELEGATE(
  [Object],
  VOID, function ProgressHandler(data) {});

DELEGATE(
  [Object],
  Object, function DataTransformer(data) {});

DELEGATE(
  [Object],
  IFuture, function DataHandler(data) {});

DELEGATE(
  [Exception],
  Boolean, function ErrorHandler(exception) {});

INTERFACE(
  'IFuture', [
     [DataHandler],
     SELF, function chain(callback) {},
     [DataTransformer],
     SELF, function done(callback) {},
     [ErrorHandler],
     SELF, function error(errback) {},
     [ProgressHandler],
     SELF, function progress(progback) {},
     SELF, function complete(callback) {},
     VOID, function cancel() {}
  ]);

INTERFACE(
  'IFutureCompleter', [
     VOID, function resolve(data) {},
     VOID, function notify(data) {},
     [Exception],
     VOID, function fail(exception) {}
  ]);

INTERFACE(
  'ICancelable', [
    VOID, function cancel() {}
  ]);

INTERFACE(
  'ITask', [
     IFuture, function run() {}
  ]);
}}}

IFuture is a core interface, which defines that future may transform propagated data or chain other task based on propagated data or handle propagated exception.

If exception was not handled it should be thrown to global scope

== Basic Implementation ==

{{{

var FutureImpl = PRIVATE_CLASS('FutureImpl', IMPLEMENTS(IFuture, IFutureCompleter, ICancelable), [
    // IFuture
    [ProgressHandler]
    SELF, function progress(progback) {},
    [DataHandler],
    SELF, function chain(callback) {},
    [ErrorHandler],
    SELF, function error(errback) {},
    SELF, function complete(callback) {},

    // ICancelable
    VOID, function cancel() {},

    [ICancelable],
    function $(cancelable) {}, // Future or Task

    // IFutureCompleter
    VOID, function resolve(data) {},
    VOID, function notify(data) {},
    VOID, function fail(exception) {}
  ]);

CLASS(ABSTRACT, 'AbstractTask', IMPLEMENTS(ITask, ICancelable), [
    // ITask
    ABSTRACT, IFuture, function run() {},

    // ICancelable
    VOID, function cancel() {},

    function $() {
      this.promise = new FutureImpl();
    }
  ]);

}}}

== Usages ==

{{{
CLASS('AjaxTask', EXTENDS(AbstractTask), [
    function $(method, url, data) {
      this.xhr = new XmlHttpRequest();
      this.xhr.onreadystatechange = this.stateChange_;
    },

    function stateChange_() {
      if (this.xhr.state == 4) {
        if (this.xhr.status == 200) {
          try {
            this.promise.resolve(JSON.parse(this.xhr.responseText);
          } catch (e) {
            this.promise.fail(Exception('JSON parse error', e));
          }
        } else {
          this.promise.fail(Exception('XHR failed, status code: ' + this.xhr.status));
        }
      } else {
        this.promise.progress(this.xhr.state);
      }
    },
 
    function run() {
      this.xhr.send();
      return this.promise;
    },

    function cancel() {
      this.xhr.abort();
    }
  ]);

AjaxTask('GET', '/service', {p: 1, r: 2})
  .run()
  // try {
    .progress(doUpdateProgressBar)
    .done(doSomethingWithResults)
    .chain(doTaskBasedOnPreviousData)
  // } catch (e) {
    .error(doHandleError)
  // } finally {
    .complete(doCleanupRequest)
  // }

}}}

== TODO ==