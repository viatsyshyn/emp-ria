#summary Futures/Promises proposal

= Introduction =

From Wikipedia, the free encyclopedia:

    In computer science, future, promise, and delay refer to constructs used for synchronizing in some concurrent programming languages. They describe an object that acts as a proxy for a result that is initially unknown, usually because the computation of its value is yet incomplete.


= Details =

This library is based on CommonJS Promises/A proposal.

Main components are:
  
  * IFuture
  * ITask

{{{

DELEGATE(
  [Object],
  Object, function DataTransformer(data) {});

DELEGATE(
  [Object],
  IFuture, function DataHandler(data) {});

DELEGATE(
  [Exception],
  Boolean, function ErrorHandler(exception) {});

INTERFACE(
  'IFuture', [
     [DataTransformer]
     SELF, function transform(transformation) {},
     [DataHandler],
     SELF, function chain(callback) {},
     [ErrorHandler],
     SELF, function error(errback) {},
     VOID, function cancel() {}
  ]);

INTERFACE(
  'ITask', [
     IFuture, function run() {},
     VOID, function cancel() {}
  ]);
}}}

IFuture is a core interface, which defines that future may transform propagated data or chain other task based on propagated data or handle propagated exception.

== Basic Implementation ==

{{{

var FutureImpl = PRIVATE_CLASS('FutureImpl', IMPLEMENTS('IFuture'), [
    [DataTransformer]
    SELF, function transform(transformation) {},
    [DataHandler],
    SELF, function chain(callback) {},
    [ErrorHandler],
    SELF, function error(errback) {},
    VOID, function cancel() {},

    [ITask],
    function $(task) {},

    VOID, function populate(data) {},
    VOID, function fail(exception) {}
  ]);

CLASS(ABSTRACT, 'AbstractTask', IMPLEMENTS(ITask), [
    ABSTRACT, IFuture, function run() {},
    VOID, function cancel() {},

    function $() {
      this.promise = new FutureImpl();
    }
  ]);

}}}

== Usages ==

{{{
CLASS('AjaxTask', EXTENDS(AbstractTask), [
    function $(method, url, data) {
      this.xhr = new XmlHttpRequest();
      this.xhr.onreadystatechange = this.stateChange_;
    },

    function stateChange_() {
      if (this.xhr.state == 4 && this.xhr.status == 200) {
        this.promise.propagate(JSON.parse(this.xhr.responseText);
      }
    },
 
    function run() {
      this.xhr.send();
      return this.promise;
    },

    function cancel() {
      this.xhr.abort();
    }
  ]);

AjaxTask('GET', '/service', {p: 1, r: 2})
  .run()
  .chain(doSomething)
  .transform(transformData)
  .chain(doSomethingElse)
  .error(handleError)

}}}

== TODO ==

  * Think about default error handling
  * Think about break mechanism