#summary Futures/Promises proposal

= Introduction =

From Wikipedia, the free encyclopedia:

    In computer science, future, promise, and delay refer to constructs used for synchronizing in some concurrent programming languages. They describe an object that acts as a proxy for a result that is initially unknown, usually because the computation of its value is yet incomplete.


= Details =

This library is based on CommonJS Promises/A proposal.

Main components are:
  
  * IFuture
  * ITask

{{{

DELEGATE(
  [Object],
  VOID, function ProgressHandler(data) {});

DELEGATE(
  [Object],
  Object, function DataTransformer(data) {});

DELEGATE(
  [Object],
  ITask, function DataHandler(data) {}); // may be should return IFuture

DELEGATE(
  [Exception],
  Boolean, function ErrorHandler(exception) {});

INTERFACE(
  'IFuture', [
     [DataHandler],
     SELF, function chain(callback) {},
     [DataTransformer],
     SELF, function done(callback) {},
     [ErrorHandler],
     SELF, function error(errback) {},
     [ProgressHandler],
     SELF, function progress(progback) {},
     SELF, function complete(callback) {},
     VOID, function cancel() {}
  ]);

INTERFACE(
  'IFutureCompleter', [
     VOID, function resolve(data) {},
     VOID, function notify(data) {},
     [Exception],
     VOID, function fail(exception) {}
  ]);

INTERFACE(
  'ICancelable', [
    VOID, function cancel() {}
  ]);

INTERFACE(
  'ITask', [
     IFuture, function run() {}x
  ]);
}}}

IFuture is a core interface, which defines that future may transform propagated data or chain other task based on propagated data or handle propagated exception.

== Basic Implementation ==

{{{

var FutureImpl = PRIVATE_CLASS('FutureImpl', IMPLEMENTS(IFuture, IFutureCompleter, ICancelable), [
    // IFuture
    [ProgressHandler]
    SELF, function progress(progback) {},
    [DataHandler],
    SELF, function chain(callback) {},
    [ErrorHandler],
    SELF, function error(errback) {},
    SELF, function complete(callback) {},

    // ICancelable
    VOID, function cancel() {},

    [ICancelable],
    function $(task) {},

    // IFutureCompleter
    VOID, function resolve(data) {},
    VOID, function notify(data) {},
    VOID, function fail(exception) {}
  ]);

CLASS(ABSTRACT, 'AbstractTask', IMPLEMENTS(ITask, ICancelable), [
    // ITask
    ABSTRACT, IFuture, function run() {},

    // ICancelable
    VOID, function cancel() {},

    function $() {
      this.promise = new FutureImpl();
    }
  ]);

}}}

== Usages ==

{{{
CLASS('AjaxTask', EXTENDS(AbstractTask), [
    function $(method, url, data) {
      this.xhr = new XmlHttpRequest();
      this.xhr.onreadystatechange = this.stateChange_;
    },

    function stateChange_() {
      if (this.xhr.state == 4 && this.xhr.status == 200) {
        this.promise.propagate(JSON.parse(this.xhr.responseText);
      }
    },
 
    function run() {
      this.xhr.send();
      return this.promise;
    },

    function cancel() {
      this.xhr.abort();
    }
  ]);

AjaxTask('GET', '/service', {p: 1, r: 2})
  .run()
  // try {
  .progress(doUpdateProgressBar)
  .done(doSomethingWithResults)
  .chain(doTaskBasedOnPreviousData)
  // } catch (e) {
  .error(doHandleError)
  // } finally {
  .complete(doCleanupRequest)
  // }

}}}

== TODO ==

  * Think about default error handling