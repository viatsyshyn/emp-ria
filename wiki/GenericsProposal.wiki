#summary Generics Proposal
#labels Featured

= Introduction =

From Wikipedia, the free encyclopedia:
   
   Generics are a facility of generic programming that was added to the Java programming language in 2004 as part of J2SE 5.0. They allow "a type or method to operate on objects of various types while providing compile-time type safety." A common use of this feature is when using a Java Collection that can hold objects of any type, to specify the specific type of object stored in it.


= Details =

Generic class 

{{{

DELEGATE(
  GENERIC('T'),
  [[T, T]],
  Boolean, function Comparator(_1, _2) {});

// Map<TKey, TValue>
CLASS(
  GENERIC('TKey', 'TValue'),
  'MyBaseMap', [
     [[T, T]],
     ABSTRACT, T, function add(t1, t2) {}
  ]);

INTERFACE(
  GENERIC('T', ClassOf(MyBase)), // may interfaces be GENERIC ?
  'MyIfc', [
     T, 'param' // not a property, but a shortcut ?
  ]);

// Dictionary<T>
CLASS(
  GENERIC('T', ImplementorOf(MyIfc)),
  'MyDictionary', 
      EXTENDS(MyBase.OF(String, T)),
      IMPLEMENTS(MyIfc.OF(T)), [ 

    T, 'param',

    [[T]],
    function $(param) {},

    [[T, T]],
    T, function add(_1, _2) { return _1 + _2; },

    READONLY, Comparator.OF(T), 'comparator'
  ]);
}}}

Instantiation

{{{
// first one arg is generalization of generic MyGenericClass<T>
var instance = MyDictionary(Number, 1); // specified with Number
}}}

Generics typing is check only in DEBUG mode. Generics typing is available via reflection

=== Impelementation notes ===

All classes are generics with zero or more params. Generalizations has readonly protected fields. If base class has generalization, children can use same name (reuse) it as its own generalization. Generalizations fields are protected as well. But public are only getters of unspecified generalizations of class.

{{{
CLASS(
  GENERIC('TKey', 'TValue'),
  'Dictionary', [
    READONLY, List.OF(TKey), 'keys',
    READONLY, List.OF(TValue), 'values',

    [[TKey, TValue]], 
    VOID, function add(key, value) {}
  ]);

var base = new Dictionary(String, Boolean);
child.getSpecsOf('TKey') === String;
child.getSpecsOf('TValue') === Boolean;

CLASS(
  GENERIC('TValue'),
  'StringDictionary', EXTENDS(Dictionary.OF(String, TValue), [
    [[Object]],
    function $fromObject(hash) {
      for(var k in hash) if (has.hasOwnProperty(k))
        this.add(k, hash[k]);
    }
  ]);

var child = new StringDictionary.$fromObject(Number, {}); 

child.getSpecsOf('TKey') === undefined;
child.getSpecsOf('TValue') === String;

child.add(5, '') // <-- triggers error 5 is not String
}}}

{{{
var instance = new Dictinary(String, Number);
instance.__PROTECTED.__SPECS.TKey === String;
instance.__PROTECTED.__SPECS.TValue === Number;

Dictionary = function () {
  var TKey = ria.__API.generalizedType('TKey'),
      TValue = ria.__API.generalizedType('TValue', [ClassOf(Base), ImplementerOf(MyIfc), ImplementerOf(MyIfc2)]),

  function Dictionary() {
    var args = ria.__API.clone(arguments),
        specsCount = Dictionary.__META.specsNames.length,
        specs = args.slice(0, specsCount);
    args = args.slice(specsCount);

    var factory = Dictionary.$$ || ria.__API.init;
    return factory(this, Dictionary, Dictionary.prototype.$, args, specs); 
  }

  ria.__API.clazz(..., [TKey, TValue]);

  Dictionary.$fromObject = function () {
    var args = ria.__API.clone(arguments),
        specsCount = Dictionary.__META.specsNames.length,
        specs = args.slice(0, specsCount);

    var factory = Dictionary.$$ || ria.__API.init;
    return factory(this, Dictionary, Dictionary.prototype.$fromObject, args.slice(specsCount), specs); 
  }

  Dictionary.OF = function OF(TKey, TValue) {
    var specs = ria.__API.clone(arguments);
    VALIDATE_ARGS(Dictionary.__META.specNames, Dictionary.__META.specTypes, specs);
    return ria.__API.specify(Dictionary, specs)
  };

  Dictionary.prototupe.add = function (a,b) {},
  ria.__API.method(Dictionary, 'add', Dictionary.prototype.add, undefined, ['a', 'b'], [TKey, TValue], []);

  return Dictinary
}();
}}}

=== Compilation ===

{{{
DELEGATE(
  GENERIC('TKey', 'TValue'),
  [[TValue]],
  TKey, function Indexer(value) {});
}}}

{{{
test.Indexer = function () {
  var TKey = new ria.__API.GenerializedType('TKey');
  var TValue = new ria.__API.GenerializedType('TValue');
  return ria.__API.delegate('test.Indexer', TKey, [TValue], ['value'], [TKey, TValue]);
}();
}}}

{{{
INTERFACE(
  GENERIC('TKey', 'TValue'),
  'MyComparatorIfc', [
    [[TKey, TValue]],
    Boolean, function compare(_1, _2) {}
  ]
}}}

{{{
test.MyComparatorIfc = function () {
  var TKey = new ria.__API.GenerializedType('TKey');
  var TValue = new ria.__API.GenerializedType('TValue');
  return ria.__API.ifc('test.MyComparatorIfc', [
    ['compare', Boolean, [TKey, TValue], ['_1', '_2']]
  ], [TKey, TValue]); 
}();
}}}

{{{
CLASS(
  GENERIC('TKey', 'TValue'),
  'MyClass', IMPLEMENTS(test.MyComparatorIfc.OF(TKey, TValue), [
    [[TKey, TValue]],
    Boolean, function compare(_1, _2) {}
  ]);
}}}

{{{
test.MyClass = function () {
  var TKey = new ria.__API.GenerializedType('TKey');
  var TValue = new ria.__API.GenerializedType('TValue');

  function MyClass() {}
  ria.__API.clazz(MyClass, 'test.MyClass', ria.__API.Class
     , [ria.__API.specify(test.MyComparatorIfc, TKey, TValue)], [], [TKey, TValue]);

  MyClass.prorotype.compare = function (_1, _2) {};
  ria.__API.method(MyClass, MyClass.prototype.compare, 'compare', Boolean, [TKey, TValue], []);

  return MyClass;
}();
}}}